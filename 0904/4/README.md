# 📋 Todo & Q&A 프로젝트 아키텍처 스터디 가이드

안녕하세요! 이 문서는 우리 **Todo & Q&A 프로젝트**가 어떤 **'설계 철학'** 과 **'구조'** 를 가지고 만들어졌는지 공유하기 위해 작성되었습니다.

이 프로젝트의 목표는 단순히 기능을 '동작'하게 만드는 것을 넘어, 어떻게 하면 **유지보수하기 쉽고, 테스트하기 용이하며, 변화에 유연하게 대처**할 수 있는 애플리케이션을 만들 수 있을까? 라는 고민을 담는 것이었습니다.

이 고민을 해결하기 위해, 우리는 두 가지 핵심 무기를 선택했습니다.

1.  **설계 철학 (The 'Why'):** **도메인 주도 설계 (DDD)**
2.  **구현 구조 (The 'How'):** **헥사고날 아키텍처 (Hexagonal Architecture)**

---

## 1. 🚀 우리의 설계 철학: 도메인 주도 설계 (DDD)

가장 먼저, 우리는 "무엇이 가장 중요한가?"라는 질문을 던졌습니다.
우리의 답은 데이터베이스나 멋진 프레임워크가 아닌, **"비즈니스 로직(도메인)"** 그 자체였습니다.

DDD(Domain-Driven Design)는 **이 순수한 비즈니스 규칙을 코드의 중심에 두는 설계 접근 방식**입니다.

### A. DDD가 무엇인가요?

DDD는 복잡한 비즈니스 문제를 해결하기 위해, 코드와 실제 비즈니스(도메인)의 모습을 똑같이 만들려는 접근법입니다. 이를 위해 두 가지 수준의 설계를 제안합니다.

#### 1. 전략적 설계 (Strategic Design): '숲'을 그리는 일

> **"어떤 '문제 영역'들이 있고, 그들의 경계는 어디인가?"**

비즈니스 전체를 보고 논리적인 경계를 나누는 거시적인 설계입니다.

* **바운디드 컨텍스트 (Bounded Context):**
    * '문제 영역'을 나누는 논리적인 경계입니다. (예: '쇼핑몰'이라면 '주문 영역', '결제 영역', '배송 영역')
    * 우리 프로젝트에서는 **'Todo 컨텍스트'** 와 **'Q&A 컨텍스트'** 라는 두 개의 명확한 경계를 식별했습니다.
* **컨텍스트 맵 (Context Map):**
    * 이 영역(컨텍스트)들이 서로 어떻게 관계를 맺는지 정의한 '지도'입니다.
    * 현재 우리 프로젝트의 두 컨텍스트는 **서로 관계가 없는 '독립적인 섬'** 입니다.

#### 2. 전술적 설계 (Tactical Design): '나무'를 심는 일

> **"하나의 '문제 영역' 내부는 어떻게 만들어야 하는가?"**

하나의 바운디드 컨텍스트를 구현하기 위한 '도구 상자'입니다.

* **엔티티 (Entity):**
    * 고유한 식별자(ID)를 가지며, '행위(Business Logic)'를 갖는 객체입니다.
    * 단순한 데이터 덩어리가 아닙니다. `src/domain/models.py`의 `Todo` 엔티티는 스스로의 상태를 변경하는 `complete()`, `uncomplete()` 같은 '행위'를 포함합니다.
* **애그리거트 (Aggregate):**
    * '데이터 일관성'을 지키기 위한 '관련 객체 묶음'입니다. 이 묶음 전체가 하나의 '트랜잭션 단위'가 됩니다.
    * 이 묶음에는 **'대표(루트, Root)'** 가 반드시 하나 있습니다. (e.g., `Question`과 `Answer`가 묶여있다면, `Question`이 '루트'입니다.)
    * **핵심 원칙:** 외부에서는 이 '대표(루트)'하고만 소통할 수 있습니다. 묶음 내부의 다른 객체(e.g., `Answer`)에 접근하려면, 반드시 '대표(루트)'를 통해서만 가능합니다.
    * **이유:** '대표'가 문지기 역할을 하며 "이 작업은 규칙에 맞아. 통과!" 또는 "이건 안 돼. 거절!"처럼 비즈니스 규칙과 일관성을 지켜주기 때문입니다.
* **리포지토리 (Repository):**
    * 엔티티(객체)를 '저장'하고 '조회'하는 기능을 추상화한 '창구'입니다.
    * DDD는 "어떻게 저장할지(e.g., SQL? NoSQL?)"는 묻지 않고, "저장해줘"라는 '행위'만 정의합니다. (e.g., `TodoRepository`)

---

## 2. 🛡️ 우리의 구현 구조: 헥사고날 아키텍처

DDD라는 '철학'을 정했다면, 이 소중한 비즈니스 로직(도메인)을 어떻게 '물리적으로' 구현하고 보호해야 할까요?

그 해답으로 우리는 **헥사고날 아키텍처(Hexagonal Architecture)**, 일명 **'포트와 어댑터(Ports & Adapters)'** 구조를 채택했습니다. 이는 **클린 아키텍처**의 철학을 따르는 구체적인 방식 중 하나입니다.

### A. 헥사고날 아키텍처가 무엇인가요?

이 아키텍처의 핵심 규칙은 단 하나입니다.

> **"모든 의존성은 '바깥(Infrastructure)'에서 '안쪽(Domain)'으로만 향해야 한다."**

이 구조를 **'성(Castle)'** 에 비유해 보겠습니다.

* **🏯 성의 중심부 (The "Inside" - 안쪽):**
    * 왕과 왕비, 즉 **가장 중요한 '비즈니스 로직(도메인)'** 이 사는 곳입니다.
    * 이들은 '바깥 세상'의 존재(DB, API)를 전혀 알지 못하며, 알아서도 안 됩니다.

* **🌍 성 밖 (The "Outside" - 바깥쪽):**
    * 데이터베이스, 웹 프레임워크(FastAPI), 결제 API 등 **'외부 기술'** 의 세계입니다.

이 둘을 어떻게 분리하고 연결할까요?

* **🚪 포트 (Ports - 성문):**
    * '안쪽(도메인)'에서 정의한 **유일한 '연결 통로(인터페이스)'** 입니다.
    * 왕(도메인)은 "나는 비밀번호를 암호화할 '포트'가 필요하다"라고 선언만 할 뿐, '어떻게' 암호화하는지는 모릅니다. (e.g., `PasswordManager` 프로토콜)

* **🔌 어댑터 (Adapters - 성문 경비병/다리):**
    * '바깥쪽(외부 기술)'에서 이 '포트'에 연결하기 위해 **구현한 '구현체'** 입니다.
    * **Inbound Adapter (입력 어댑터):** 외부의 요청(HTTP)을 '안쪽'의 언어로 번역해 '포트'로 전달합니다. (e.g., `question.py` 라우터)
    * **Outbound Adapter (출력 어댑터):** '안쪽'의 요청을 '외부 기술'로 번역해 수행합니다. (e.g., `BcryptPasswordManager`가 `PasswordManager` '포트'에 연결되어 실제 암호화를 수행)

이 구조 덕분에, 우리는 데이터베이스를 `SQLite`에서 `PostgreSQL`로 바꾸더라도, **'안쪽'의 핵심 비즈니스 로직은 단 한 줄도 수정할 필요가 없습니다.**

---

## 3. 🔧 아키텍처를 떠받치는 핵심 원칙들

이 '성'을 실제로 짓기 위해 사용된 몇 가지 중요한 원칙과 패턴입니다.

### A. 의존성 역전 원칙 (DIP)

> **"구체적인 것(Infrastructure)이 추상적인 것(Domain)에 의존해야 한다."**

이것이 헥사고날 아키텍처를 가능하게 하는 핵심 원동력입니다.
보통은 '상위 계층'이 '하위 계층(외부 기술)'을 의존하지만, DIP는 이 관계를 **'역전'** 시킵니다.
'외부 기술(어댑터)'이 '안쪽(포트)'을 바라보게 만듭니다. `BcryptPasswordManager`가 `PasswordManager` 인터페이스를 구현(의존)하는 것이 그 예입니다.

### B. DTO - Entity - DAO의 명확한 분리

데이터 객체가 각 계층에서 다른 '역할'을 갖도록 명확히 분리했습니다.

1.  **DTO (Data Transfer Object):**
    * `src/infrastructure/adapters_in/dtos.py`
    * **역할:** API 요청/응답(HTTP)을 위한 '데이터 상자'. IP 마스킹 등 '표현'을 위한 로직을 처리합니다.
2.  **Entity (Domain Model):**
    * `src/domain/models.py`
    * **역할:** '왕과 왕비'. 순수한 비즈니스 '행위'를 가진 핵심 객체입니다.
3.  **DAO (Data Access Object):**
    * `src/infrastructure/adapters_out/datebase/daos.py`
    * **역할:** '외부 세계'인 데이터베이스 테이블과 1:1로 매핑되는 객체.

### C. 작업 단위 (Unit of Work - UoW) 패턴

* **비유:** '장바구니'와 같습니다.
* **역할:** 여러 개의 데이터 변경 작업을 하나의 '트랜잭션(장바구니)'으로 묶어, 모두 성공(결제)하거나 모두 실패(주문 취소)하게 만듭니다.
* `SqlAlchemyUnitOfWork`가 이 '장바구니' 역할을 하여 데이터 일관성을 보장합니다.

---

## 4. 🤔 "규칙은 깨라고 있다" - 우리의 현실적인 트레이드오프

이론을 배우는 것은 쉽지만, 현실에 적용하는 것은 어렵습니다.
이 프로젝트에서 우리는 **'이론적 순수함'** 과 **'현실적 실용성'** 사이에서 두 가지 큰 고민을 했습니다.

### A. 고민 1: DTO-Entity-DAO 분리 (생산성 vs. 결합도)

* **문제:** DTO, 도메인 Entity, 그리고 DB DAO를 모두 분리하자, 이들 간의 데이터를 변환해주는 `mappers.py` 같은 '보일러플레이트(단순 반복)' 코드가 엄청나게 늘어났습니다.

* **현실적인 대안들 (The Alternatives):**
    이 보일러플레이트 코드는 실무에서 '개발 속도'와 '생산성'에 직접적인 영향을 줍니다. 그래서 많은 프로젝트, 특히 초기 단계나 소규모 프로젝트에서는 다음과 같은 '타협안'을 선택합니다.

    1.  **Entity + DAO 통합 (ActiveRecord 패턴):**
        모델 객체(Entity)가 스스로 DB 저장/조회(DAO) 기능까지 갖는 방식입니다. (e.g., `user.save()`)
        * **단점:** 도메인 모델(Entity)이 특정 데이터베이스 기술(DAO)에 **강하게 결합**됩니다. '성의 중심부(도메인)'가 '외부(DB)'를 알게 되므로, 헥사고날 아키텍처의 원칙이 깨집니다.

    2.  **DTO + DAO 통합 (e.g., `sqlmodel`):**
        FastAPI 생태계의 `sqlmodel` 라이브러리가 이 접근의 좋은 예시입니다. API 명세(DTO)와 DB 스키마(DAO)를 **하나의 클래스**로 정의하게 해줍니다.
        * **단점:** API 명세(표현 계층)와 DB 스키마(데이터 계층)가 **결합**됩니다. API에서 필드 하나를 바꾸는 것이 의도치 않게 DB 스키마에 영향을 줄 수 있습니다.

    3.  **DTO + Entity + DAO 모두 통합:**
        소규모 프로젝트나 프로토타이핑에서는 2번의 `sqlmodel` 객체에 아예 비즈니스 로직(Entity의 행위)까지 추가하여, **모든 것을 하나의 클래스**로 합쳐버리기도 합니다.
        * **단점:** **극도로 높은 결합도.** API, 비즈니스 로직, DB가 똘똘 뭉쳐있어, 사소한 변경 하나가 다른 모든 곳에 연쇄적인 파급 효과(Side Effect)를 일으킵니다.

* **✅ 우리의 선택:** **"모든 계층을 의도적으로 분리한다."**

* **이유:**
    단순히 '개발 속도'가 느려지는 단점에도 불구하고, 우리는 **'결합도를 낮추는 것'** 이 장기적으로 더 큰 이익이라고 판단했습니다. 지금은 '학습'이 목적이었지만, 실무에서는 **'각 계층이 서로 다른 이유로, 서로 다른 속도로 변경된다'** 는 점이 더 중요합니다.
    * **표현 계층(DTO)의 변경:** "API에서 `creator_ip`를 마스킹해서 보여주세요."
    * **도메인(Entity)의 변경:** "Todo를 `complete`할 때, 특정 비즈니스 규칙을 추가해 주세요."
    * **데이터 계층(DAO)의 변경:** "DB 성능을 위해 `TodoTable`의 인덱스를 수정해 주세요."
    
    만약 이 모든 것이 하나의 클래스로 묶여있었다면, 1번의 요구사항을 수정하다가 2번, 3번에 버그를 만들 수 있습니다. 우리는 보일러플레이트 코드를 작성하는 비용을 치르는 대신, 각 계층이 자신의 '책임'에만 집중하고, 다른 계층의 변경에 영향을 받지 않는 **'유지보수의 유연함'** 을 얻었습니다.

### B. 고민 2: Q&A 애그리거트 (이론적 순수함 vs. 현실적 성능)

* **이론 (DDD의 규칙):** 위에서 배운 '애그리거트' 규칙을 `Q&A`에 적용해봅시다. '질문(Question)'과 '답변(Answer)'은 하나의 묶음(애그리거트)이며, '질문'이 '루트(대표)'입니다. 규칙대로라면, '답변'을 추가/수정/삭제하는 모든 행위는 반드시 '질문' 엔티티를 통해서만 이루어져야 합니다. (`question.add_answer(...)`처럼)
* **현실 (치명적 문제):** 만약 한 질문에 '답변'이 10,000개 달려있다면?
    * 규칙대로면, 답변 1개를 추가하기 위해 **관련 없는 답변 10,000개를 모두 DB에서 불러와야** 합니다.
    * 이는 끔찍한 **성능 저하**를 유발합니다.
* **✅ 우리의 선택:** **"규칙을 어긴다."**
* **이유:** 우리 프로젝트의 'Q&A' 도메인은 "답변이 달리면 질문의 상태가 변경된다"와 같은 **복잡한 비즈니스 규칙이 없었습니다.**
    * `AnswerService`는 `Question`이 존재하는지만 확인(참조 무결성)하고, `AnswerRepository`에 직접 '답변'을 추가합니다.
    * **'이론적 순수함'** 보다 **'현실적인 성능'** 이 훨씬 더 중요한 트레이드오프라고 판단했습니다.

---

## 5. 💡 더 나아가: 실무에서의 DDD (MSA & EDA)

우리는 프로젝트의 규모와 복잡도를 고려하여 **'모노리식(Monolithic)' 아키텍처**를 선택했습니다. `Todo`와 `Q&A`라는 두 개의 '바운디드 컨텍스트'가 하나의 애플리케이션, 하나의 데이터베이스 안에서 실행됩니다.

하지만, 만약 비즈니스가 거대해진다면 실무에서는 어떻게 할까요?

**DDD의 '전략적 설계'는 '마이크로서비스 아키텍처(MSA)'로 가기 위한 완벽한 '설계도'가 됩니다.**

* **논리적 경계에서 물리적 경계로 (MSA):**
    DDD로 설계한 '바운디드 컨텍스트'는 MSA의 '마이크로서비스'로 분리하기 위한 가장 이상적인 기준입니다. 'Todo 컨텍스트'와 'Q&A 컨텍스트'는 각자 독립된 서버, 독립된 데이터베이스를 가진 **물리적으로 분리된 서비스**가 될 수 있습니다.

* **분리된 서비스 간의 소통 (EDA):**
    '고민 2'에서 우리는 '성능'을 위해 애그리거트 규칙을 완화했습니다. 이 선택은 '답변'과 '질문' 간의 복잡한 비즈니스 규칙이 *없었기에* 가능했습니다.

    그렇다면, 만약 "답변이 달리면 질문 작성자에게 알림을 보낸다"와 같은 ***새로운* 복잡한 규칙이 추가된다면** 어떻게 될까요?

    현재 구조(모노리식)에서는 `AnswerService`가 `NotificationService`까지 호출해야 하는 등 서비스 간 **결합도가 높아지기 시작합니다.** '고민 2'에서 선택한 실용적인 해법이, 새로운 복잡성을 만나 한계에 부딪히는 것입니다.

    이때 **이벤트 기반 아키텍처(Event-Driven Architecture)** 가 이 문제를 해결합니다.

    1.  `Answer 서비스`는 자신의 할 일(답변 저장)만 하고, `AnswerAdded`라는 **'이벤트(방송)'** 를 발행(Publish)합니다.
    2.  `Question 서비스`나 별도의 `Notification 서비스`는 이 '방송'을 구독(Subscribing)하고 있다가, 각자 자신의 할 일('최근 답변 시간' 갱신 / '알림' 발송)을 처리합니다.
    3.  이처럼 여러 서비스에 걸쳐 하나의 비즈니스 로직을 처리할 때 데이터 일관성을 맞추는 패턴을 **Saga 패턴**이라고 부릅니다.

이처럼, 우리 프로젝트는 DDD의 '논리적 설계'를 모노리식으로 구현한 **첫 단계**이며, 비즈니스가 복잡해짐에 따라 자연스럽게 MSA와 EDA라는 다음 아키텍처로 진화할 수 있는 **확장성을 갖춘 구조**입니다.

---

## 6. ✨ 결론: 장점과 단점 요약

이 아키텍처를 선택하면서 우리가 얻은 것과 감수해야 했던 것들입니다.

### 장점 (Pros) 👍

* **최고의 테스트 용이성 (Testability):**
    핵심 비즈니스 로직(도메인)을 DB나 API 없이 순수하게 테스트할 수 있습니다. 가짜(Fake) 리포지토리를 주입하면 되므로 매우 빠르고 격리된 테스트가 가능합니다.

* **명확한 책임 분리 (Clarity):**
    버그가 발생했을 때, 이것이 'API 요청(DTO)'의 문제인지, '비즈니스 규칙(Entity)'의 문제인지, 'DB 저장(DAO)'의 문제인지 명확히 알 수 있습니다.

* **유연성 및 기술 교체 용이 (Flexibility):**
    데이터베이스를 바꾸거나, `bcrypt` 암호화를 다른 것으로 바꿔도 '성의 중심부(도메인)' 코드는 전혀 영향을 받지 않습니다.

* **비즈니스 로직에 집중 (Business-Focused):**
    코드가 프레임워크나 DB가 아닌, 실제 '비즈니스'의 모습을 반영하게 됩니다.

### 현실적인 고민과 단점 (Cons) 👎

* **보일러플레이트 코드 증가 (Boilerplate):**
    가장 큰 단점입니다. 간단한 기능 하나를 추가하기 위해 `DTO`, `Entity`, `DAO`, `Mapper`, `Port`, `Adapter` 등 많은 파일을 만들어야 합니다.

* **높은 학습 곡선 (Steep Learning Curve):**
    DDD, 헥사고날, DIP, UoW 등 배워야 할 추상적인 개념이 많아 초기 진입 장벽이 높습니다.

* **과설계(Over-engineering) 위험:**
    우리 프로젝트의 'Todo' 기능처럼 아주 단순한 CRUD만 있다면, 이 모든 구조는 '닭 잡는 데 소 잡는 칼'을 쓰는 격일 수 있습니다.

### 최종 요약

DDD라는 **'설계 나침반'** 과 헥사고날 아키텍처라는 **'견고한 성벽'** 은,
**"빠른 개발"** 보다는 **"지속 가능한 개발"** 을 위한 강력한 도구입니다.

초기 설정과 반복 코드는 많지만, 프로젝트가 복잡해지고 요구사항이 끊임없이 변경될수록, 이 구조가 왜 중요한지 깨닫게 될 것입니다.

이 프로젝트가 아키텍처를 고민하는 여러분에게 좋은 참고 자료가 되기를 바랍니다!
